package org.wikimedia.revdiffsearch;
import java.util.*;
import java.util.logging.*;
import java.lang.reflect.*;

public class ClassUtils {
  private static final Logger logger = Logger.getLogger(ClassUtils.class.getName());

  /**
   * Returns an instance of the class described in the {@link String} argument.
   *
   * @param clsname a fully-qualified class name with optional constructor arguments
   * @param def     a default instance, used when clsname is null or failed to be instantiated.
   * @param basecls      {@link Class} object that specifies the type of the return value (eg. Collection.cls).
   * @return             an instance the given class generated by the default constructor with no argument.
   */
  public static <T> T newInstanceOf(String clsname, T def, Class<T> basecls) {
    if ( clsname == null ) {
      return def;
    }
    String[] a = clsname.split("\\(");
    String[] args = new String[0];
    if ( a.length > 1 ) {
      clsname = a[0];
      args = a[1].substring(0,a[1].length()-1).split(",");
    }
    try {
      Class<? extends T> cls = Class.forName(clsname).asSubclass(basecls);
      logger.info("class found: " + clsname);
      for ( Constructor<?> cs: cls.getConstructors() ) {
        try {
          if ( cs.getParameterTypes().length != args.length ) {
            continue;
          }
          Object[] args_ = new Object[args.length];
          for ( int i = 0; i < args.length; ++i ) {
            args_[i] = parseValue(args[i], cs.getParameterTypes()[i]);
          }
          return (T)cs.newInstance((Object[])args);
        } catch ( IllegalArgumentException e ) {
          logger.info(e.toString());//!
          e.printStackTrace();//!
          // do nothing
        }
      }
      logger.warning("no valid constructor for: " + Arrays.asList(args));
    } catch (ClassNotFoundException e) {
      logger.warning("class not found: " + clsname);
    } catch (InstantiationException e) {
      logger.warning(e.toString());
    } catch (InvocationTargetException e) {
      logger.warning(e.toString());
    } catch (IllegalAccessException e) {
      logger.warning(e.toString());
    }
    return def;
  }

  public static Object parseValue(String value, Class<?> cls) {
    if ( cls == String.class ) {
      return value;
    } else if ( cls == Integer.class || cls == int.class ) {
      return Integer.valueOf(Integer.parseInt(value));
    } else if ( cls == Double.class || cls == double.class ) {
      return Double.valueOf(Double.parseDouble(value));
    }
    throw new IllegalArgumentException("given value is not parsable: " + cls);
  }
}
